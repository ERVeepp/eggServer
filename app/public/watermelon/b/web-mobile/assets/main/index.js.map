{"version":3,"sources":["assets/scripts/Fruit.js","assets/scripts/Game.js","assets/scripts/Juice.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACI;AAEA;AACI;AADQ;AAGZ;AACI;AACA;AACA;AAEH;AACD;AAGA;AACI;AACA;AACI;AACA;;AACA;AACI;AAA+B;AAAM;AAAP;AACjC;AACJ;AACJ;AAxBI;;;;;;;;;;ACAT;AACI;AACA;AACI;AACA;AAFQ;AAFO;AAQvB;AACI;AACA;AACI;AACA;AACA;AAHQ;AAFW;AAS3B;AACI;AAEA;AACI;AACI;AACA;AAFI;AAKR;AACI;AACA;AAFI;AAKR;AACA;AACI;AACA;AAFS;AAKb;AACI;AACA;AAFS;AAKb;AACA;AACI;AACA;AAFO;AAIX;AACI;AACA;AAFQ;AAIZ;AACI;AACA;AAFQ;AAIZ;AACI;AACA;AAFQ;AAIZ;AACI;AACA;AAFO;AAvCH;AA6CZ;AACI;AAEA;AACA;AACA;AACA;;AAGA;AAEA;AAEH;AACD;AACI;AACH;AAED;AACA;AACI;AACA;AACA;;AAEA;;AAGA;AACA;;AAGA;AACA;AAEA;AAEA;AACA;;AAEA;AACI;AACA;AACA;AACA;AACA;AACH;;AAED;;AACA;;AACA;;AACA;;AAEA;AACH;AAED;AAAqB;AAAR;AAAQ;;AACjB;AACA;AACH;AAED;AACA;AAAgB;;AACZ;AACA;AAFY;AAAA;AAAA;AAMZ;AAEA;AARY;AAAA;AAUZ;AACA;AAEA;AACI;AACA;;;AAGA;AACI;;AACA;;AACA;AACH;AACJ;AAED;AACH;AACD;AACI;AACA;AACH;AACD;AACA;AACI;AACI;AACH;AACG;AACH;AACG;AACA;AACH;AACJ;AACD;AACA;AAAoB;;AAChB;AACA;AAEA;AACI;AACA;AAF6B;AAKjC;AACA;AAEA;AACA;;AAGA;AACA;AACI;AACA;AAAmD;AAAA;AAAA;;AAE/C;AAAwC;AAAG;AAAJ;;AACvC;AACA;AACA;AAEH;AACJ;AAED;AACH;AAED;AACI;AACA;AACA;AACA;AACH;AAED;AACA;AAAiC;AAAV;AAAU;;AAC7B;AACA;AACA;AACH;AACD;AACA;AAAkC;AAAA;AAC9B;;AAEA;;AAEA;AACA;AAN8B;AAAA;AAAA;AAU9B;AAAiC;AAAG;AAAJ;AAEhC;AAEA;;AACA;AACI;AAEA;;AAGA;AACA;AACI;AADsB;AAGtB;AADD;AAGN;AACG;AACA;AACH;AACJ;AAED;AACA;AACI;AACA;AACA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACH;AACD;AACA;AACI;;AAEA;AACH;AA3PI;;;;;;;;;;ACjBT;AACI;AACH;;AAED;AACI;AAEA;AACI;AACI;AACA;AAFM;AAIV;AACI;AACA;AAFI;AAIR;AACI;AACA;AAFG;AATC;AAeZ;AACI;AACA;AACA;AACH;AAED;AACA;AAAsB;;AAAA;AAGd;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AAMY;AACH;AAvBK;;AAClB;AACA;AAA6B;AAuB5B;;;AAzBiB;AA6Bd;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACI;AACH;AA1Ca;;AA4BlB;AAA6B;AAe5B;;;AAGD;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACI;AACH;AACJ;AAnFI","sourcesContent":["cc.Class({\n    extends: cc.Component,\n\n    properties: {\n        id: 0,\n    },\n    init(data) {\n        this.id = data.id\n        const sp = this.node.getComponent(cc.Sprite)\n        sp.spriteFrame = data.iconSF\n        // todo 控制一下每种水果的尺寸\n    },\n    start() {\n\n    },\n    onBeginContact(contact, self, other) {\n        // 貌似检测有点消耗性能\n        if (self.node && other.node) {\n            const s = self.node.getComponent('Fruit')\n            const o = other.node.getComponent('Fruit')\n            if (s && o && s.id === o.id) {\n                self.node.emit('sameContact', {self, other});\n            }\n        }\n    },\n});\n","const Fruit = cc.Class({\n    name: 'FruitItem',\n    properties: {\n        id: 0,\n        iconSF: cc.SpriteFrame\n    }\n});\n\nconst JuiceItem = cc.Class({\n    name: 'JuiceItem',\n    properties: {\n        particle: cc.SpriteFrame,\n        circle: cc.SpriteFrame,\n        slash: cc.SpriteFrame,\n    }\n});\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        fruits: {\n            default: [],\n            type: Fruit\n        },\n\n        juices: {\n            default: [],\n            type: JuiceItem\n        },\n\n        // 动态生成 找到批量处理预置元素的方案\n        fruitPrefab: {\n            default: null,\n            type: cc.Prefab\n        },\n\n        juicePrefab: {\n            default: null,\n            type: cc.Prefab\n        },\n\n        // todo 可以实现一个audioManager\n        boomAudio: {\n            default: null,\n            type: cc.AudioClip\n        },\n        knockAudio: {\n            default: null,\n            type: cc.AudioClip\n        },\n        waterAudio: {\n            default: null,\n            type: cc.AudioClip\n        },\n        scoreLabel: {\n            default: null,\n            type: cc.Label\n        },\n        fingerBtn: {\n            default: null,\n            type: cc.Button\n        }\n    },\n\n    onLoad() {\n        this.initPhysics()\n\n        this.isCreating = false\n        this.fruitCount = 0\n        this.score = 0\n        this.useFinger = false\n\n        // 监听点击事件 todo 是否能够注册全局事件\n        this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this)\n\n        this.initOneFruit()\n\n    },\n    start() {\n        this.fingerBtn.node.on(cc.Node.EventType.TOUCH_START, this.onFingerTouch, this)\n    },\n\n    // 开启物理引擎和碰撞检测\n    initPhysics() {\n        // 物理引擎\n        const instance = cc.director.getPhysicsManager()\n        instance.enabled = true\n        // instance.debugDrawFlags = 4\n        instance.gravity = cc.v2(0, -960);\n\n        // 碰撞检测\n        const collisionManager = cc.director.getCollisionManager();\n        collisionManager.enabled = true\n\n        // 设置四周的碰撞区域\n        let width = this.node.width;\n        let height = this.node.height;\n\n        let node = new cc.Node();\n\n        let body = node.addComponent(cc.RigidBody);\n        body.type = cc.RigidBodyType.Static;\n\n        const _addBound = (node, x, y, width, height) => {\n            let collider = node.addComponent(cc.PhysicsBoxCollider);\n            collider.offset.x = x;\n            collider.offset.y = y;\n            collider.size.width = width;\n            collider.size.height = height;\n        }\n\n        _addBound(node, 0, -height / 2, width, 1);\n        _addBound(node, 0, height / 2, width, 1);\n        _addBound(node, -width / 2, 0, 1, height);\n        _addBound(node, width / 2, 0, 1, height);\n\n        node.parent = this.node;\n    },\n\n    initOneFruit(id = 1) {\n        this.fruitCount++\n        this.currentFruit = this.createFruitOnPos(0, 400, id)\n    },\n\n    // 监听屏幕点击\n    onTouchStart(e) {\n        if (this.isCreating) return\n        this.isCreating = true\n        const {width, height} = this.node\n\n\n        const fruit = this.currentFruit\n\n        const pos = e.getLocation()\n        let {x, y} = pos\n        x = x - width / 2\n        y = y - height / 2\n\n        const action = cc.sequence(cc.moveBy(0.3, cc.v2(x, 0)).easing(cc.easeCubicActionIn()), cc.callFunc(() => {\n            // 开启物理效果\n            this.startFruitPhysics(fruit)\n\n            // 1s后重新生成一个\n            this.scheduleOnce(() => {\n                const nextId = this.getNextFruitId()\n                this.initOneFruit(nextId)\n                this.isCreating = false\n            }, 1)\n        }))\n\n        fruit.runAction(action)\n    },\n    onFingerTouch() {\n        console.log('onFingerTouch')\n        this.useFinger = true\n    },\n    // 获取下一个水果的id\n    getNextFruitId() {\n        if (this.fruitCount < 3) {\n            return 1\n        } else if (this.fruitCount === 3) {\n            return 2\n        } else {\n            // 随机返回前5个\n            return Math.floor(Math.random() * 5) + 1\n        }\n    },\n    // 创建一个水果\n    createOneFruit(num) {\n        let fruit = cc.instantiate(this.fruitPrefab);\n        const config = this.fruits[num - 1]\n\n        fruit.getComponent('Fruit').init({\n            id: config.id,\n            iconSF: config.iconSF\n        });\n\n        fruit.getComponent(cc.RigidBody).type = cc.RigidBodyType.Static\n        fruit.getComponent(cc.PhysicsCircleCollider).radius = 0\n\n        this.node.addChild(fruit);\n        fruit.scale = 0.6\n\n        // 有Fruit组件传入\n        fruit.on('sameContact', this.onSameFruitContact.bind(this))\n        fruit.on(cc.Node.EventType.TOUCH_START, (e) => {\n            // 选择道具时直接消除对应水果\n            if (this.useFinger && fruit !== this.currentFruit) {\n                const {x, y, width} = fruit\n                this.createFruitJuice(config.id, cc.v2({x, y}), width)\n                e.stopPropagation()\n                this.useFinger = false\n                fruit.removeFromParent(true)\n\n            }\n        })\n\n        return fruit\n    },\n\n    startFruitPhysics(fruit) {\n        fruit.getComponent(cc.RigidBody).type = cc.RigidBodyType.Dynamic\n        const physicsCircleCollider = fruit.getComponent(cc.PhysicsCircleCollider)\n        physicsCircleCollider.radius = fruit.height / 2\n        physicsCircleCollider.apply()\n    },\n\n    // 在指定位置生成水果\n    createFruitOnPos(x, y, type = 1) {\n        const fruit = this.createOneFruit(type)\n        fruit.setPosition(cc.v2(x, y));\n        return fruit\n    },\n    // 两个水果碰撞\n    onSameFruitContact({self, other}) {\n        other.node.off('sameContact') // 两个node都会触发，todo 看看有没有其他方法只展示一次的\n\n        const id = other.getComponent('Fruit').id\n        // todo 可以使用对象池回收\n        self.node.removeFromParent(true)\n        other.node.removeFromParent(true)\n\n        const {x, y} = other.node\n\n        this.createFruitJuice(id, cc.v2({x, y}), other.node.width)\n\n        this.addScore(id)\n\n        const nextId = id + 1\n        if (nextId <= 11) {\n            const newFruit = this.createFruitOnPos(x, y, nextId)\n\n            this.startFruitPhysics(newFruit)\n\n            // 展示动画 todo 动画效果需要调整\n            newFruit.scale = 0\n            cc.tween(newFruit).to(.5, {\n                scale: 0.6\n            }, {\n                easing: \"backOut\"\n            }).start()\n        } else {\n            // todo 合成两个西瓜\n            console.log(' todo 合成两个西瓜 还没有实现哦~ ')\n        }\n    },\n\n    // 合并时的动画效果\n    createFruitJuice(id, pos, n) {\n        // 播放合并的声音\n        cc.audioEngine.play(this.boomAudio, false, 1);\n        cc.audioEngine.play(this.waterAudio, false, 1);\n\n        // 展示动画\n        let juice = cc.instantiate(this.juicePrefab);\n        this.node.addChild(juice);\n\n        const config = this.juices[id - 1]\n        const instance = juice.getComponent('Juice')\n        instance.init(config)\n        instance.showJuice(pos, n)\n    },\n    // 添加得分分数\n    addScore(fruitId) {\n        this.score += fruitId * 2\n        // todo 处理分数tween动画\n        this.scoreLabel.string = this.score\n    }\n});\n","const RandomInteger = function (e, t) {\n    return Math.floor(Math.random() * (t - e) + e)\n}\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        particle: {\n            default: null,\n            type: cc.SpriteFrame\n        },\n        circle: {\n            default: null,\n            type: cc.SpriteFrame\n        },\n        slash: {\n            default: null,\n            type: cc.SpriteFrame\n        }\n    },\n\n    init(data) {\n        this.particle = data.particle\n        this.circle = data.particle\n        this.slash = data.slash\n    },\n\n    // 合并时的动画效果\n    showJuice(pos, width) {\n        // 果粒\n        for (let i = 0; i < 10; ++i) {\n            const node = new cc.Node('Sprite');\n            const sp = node.addComponent(cc.Sprite);\n\n            sp.spriteFrame = this.particle;\n            node.parent = this.node;\n\n            const a = 359 * Math.random(),\n                i = 30 * Math.random() + width / 2,\n                l = cc.v2(Math.sin(a * Math.PI / 180) * i, Math.cos(a * Math.PI / 180) * i);\n            node.scale = .5 * Math.random() + width / 100;\n            const p = .5 * Math.random();\n\n            node.position = pos;\n            node.runAction(\n                cc.sequence(cc.spawn(cc.moveBy(p, l),\n                    cc.scaleTo(p + .5, .3),\n                    cc.rotateBy(p + .5, RandomInteger(-360, 360))),\n                    cc.fadeOut(.1),\n                    cc.callFunc(function () {\n                        node.active = false\n                    }, this))\n            )\n        }\n\n        // 水珠\n        for (let f = 0; f < 20; f++) {\n            const node = new cc.Node('Sprite');\n            const sp = node.addComponent(cc.Sprite);\n\n            sp.spriteFrame = this.circle;\n            node.parent = this.node;\n\n            let a = 359 * Math.random(), i = 30 * Math.random() + width / 2,\n                l = cc.v2(Math.sin(a * Math.PI / 180) * i, Math.cos(a * Math.PI / 180) * i);\n            node.scale = .5 * Math.random() + width / 100;\n            let p = .5 * Math.random();\n            node.position = pos\n            node.runAction(cc.sequence(cc.spawn(cc.moveBy(p, l), cc.scaleTo(p + .5, .3)), cc.fadeOut(.1), cc.callFunc(function () {\n                node.active = false\n            }, this)))\n        }\n\n        // 果汁\n        const node = new cc.Node('Sprite');\n        const sp = node.addComponent(cc.Sprite);\n\n        sp.spriteFrame = this.slash;\n        node.parent = this.node;\n\n        node.position = pos\n        node.scale = 0\n        node.angle = RandomInteger(0, 360)\n        node.runAction(cc.sequence(cc.spawn(cc.scaleTo(.2, width / 150), cc.fadeOut(1)), cc.callFunc(function () {\n            node.active = false\n        })))\n    },\n});\n"],"file":"index.js"}